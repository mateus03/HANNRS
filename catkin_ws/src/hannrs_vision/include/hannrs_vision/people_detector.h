#ifndef _PEOPLE_DETECTOR_H
#define _PEOPLE_DETECTOR_H

#include <fstream>
#include <stdio.h>
#include <stdlib.h>

//ROS
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/PointStamped.h>
#include "hannrs_msgs/VisionDetection.h"
#include <std_msgs/String.h>
//OpenCV
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/ml/ml.hpp>
#include <opencv2/video/tracking.hpp>

#include "hannrs_vision/undistort.h"

class Entity{
public:
  float classification;
  cv::RotatedRect ellipse;
  std::vector<cv::Point> contours;
  double dist2center;
  double angle;
  geometry_msgs::Point cam_pos;
  geometry_msgs::Point world_pos;
  cv::Point2f feet;
  
  Entity(float c, cv::RotatedRect e, std::vector<cv::Point> p){
    classification = c;
    ellipse = e;
    contours = p;
  }
  
  Entity(cv::RotatedRect e, std::vector<cv::Point> p){
    ellipse = e;
    contours = p;
  }
  
  bool insideEllipse(cv::Point2f p){
    double rot = std::atan2(p.y - ellipse.center.y, p.x - ellipse.center.x);
    
    cv::Point2f ic_ellipse((p.x - ellipse.center.x)*cos(rot) + (p.y - ellipse.center.y)*sin(rot), 
				- (p.x - ellipse.center.x)*sin(rot) + (p.y - ellipse.center.y)*cos(rot));
    
    return (ic_ellipse.x/ellipse.size.width)*(ic_ellipse.x/ellipse.size.width) + (ic_ellipse.y/ellipse.size.height)*(ic_ellipse.y/ellipse.size.height) <= 1;
  }

};

const double p2mpoly[2] = {0.013050255295132, -0.016400458230773};

class PeopleDetector{
protected:
  std::string cam;
  ros::NodeHandle nh;
  ros::Publisher detections_pub;
  ros::Publisher visual_pub;
  ros::Publisher tv_pub;
  image_transport::ImageTransport it;
  image_transport::Subscriber image_sub;
  cv_bridge::CvImagePtr cv_ptr;
  bool fst_im;
  cv::Mat undistorted_im;
  cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
  cv::Ptr<cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
  std::vector<cv::Rect> surf;
  std::vector<cv::Rect> sitting;
  Undistorter* undistorter;
  CvSVM SVM;
  std::vector<Entity> people;
  std::vector<cv::KalmanFilter> KFilters;
  
  geometry_msgs::PointStamped det;
  
  int clicks;
  cv::Mat R,T;
  
  std::ofstream pos_data;
  
  void imageCB(const sensor_msgs::ImageConstPtr& msg);
  std::vector<Entity> find_contours();
  std::vector<Entity> filter_detections(std::vector<Entity> entities);
  std::vector<Entity> classify_detections(std::vector<Entity> entitiesInborders);
  void plotEntities(std::vector<Entity> entities);
  double pixel2meters(double d);
public:
  PeopleDetector();
  ~PeopleDetector();
  
  void spinOnce();
  void showImage();
  
  void detect();
  
  void CallBackFunc(int event, int x, int y, int flags);
};

#endif
