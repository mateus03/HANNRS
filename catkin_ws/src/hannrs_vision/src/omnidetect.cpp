//ROS
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <dynamic_reconfigure/server.h>
#include <hannrs_vision/UndistortConfig.h>
//OpenCV
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>

#include <math.h>
#include <iostream>
#include <fstream>

typedef struct{
  std::vector<double> pol;    // the polynomial coefficients: pol[0] + x"pol[1] + x^2*pol[2] + ... + x^(N-1)*pol[N-1]
  int length_pol;                // length of polynomial
  std::vector<double> invpol; // the coefficients of the inverse polynomial
  int length_invpol;             // length of inverse polynomial
  double xc;         // row coordinate of the center
  double yc;         // column coordinate of the center
  double c;          // affine parameter
  double d;          // affine parameter
  double e;          // affine parameter
  double width;         // image width
  double height;        // image height
}ocam_model;

class PersonDetector{
protected:
  ocam_model fisheye_model;
  
  ros::NodeHandle nh;
  image_transport::ImageTransport it;
  image_transport::Subscriber image_sub;
  cv_bridge::CvImagePtr cv_ptr;
  bool fst_im;
  cv::Mat undistorted_im;
  
  cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
  cv::Ptr<cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
  std::vector<cv::RotatedRect> ellipseMOG2;
  std::vector<cv::RotatedRect> ellipse_filtetred;
  
  dynamic_reconfigure::Server<hannrs_vision::UndistortConfig> server;
  dynamic_reconfigure::Server<hannrs_vision::UndistortConfig>::CallbackType f;
  
//   std::ofstream data_file;
  cv::FileStorage data_file;
  cv::FileStorage borders_file;
//   double lowerBound;
  std::vector<cv::Rect> surf;
  cv::Rect tv;
  cv::Point2f im_center;
  
  double sf;
  bool changed_sf;
  cv::Mat mapx, mapy;
  
  cv::Mat training, labels;
  
  void imageCB(const sensor_msgs::ImageConstPtr& msg){
    try{
      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
    }catch(cv_bridge::Exception& e){
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }
    
    if(fst_im){
      fst_im = false;
    }

    undistorted_im.setTo(cv::Scalar(0,0,0));
    
    if(changed_sf){
      create_undistort_map();
      changed_sf = false;
    }
    
    cv::remap( cv_ptr->image, undistorted_im, mapx, mapy, cv::INTER_LINEAR, cv::BORDER_TRANSPARENT, cvScalarAll(0));

    //update the background model
    pMOG2->operator()(undistorted_im, fgMaskMOG2);

  }

  void create_perspecive_undistortion_LUT( CvMat *mapx, CvMat *mapy){
    float Nxc = mapx->rows/2.0;
    float Nyc = mapx->cols/2.0;
    float Nz  = -mapx->cols/sf;
    double M[3];
    double m[2];
    double norm;
    double theta;
    double t, t_i;
    double rho, x, y;
    double invnorm;
    int j,k;
    
    for (int i = 0; i < mapx->rows; i++)
      for (j = 0; j < mapx->cols; j++){   
	M[0] = (i - Nxc);
	M[1] = (j - Nyc);
	M[2] = Nz;
	
	norm = sqrt(M[0]*M[0] + M[1]*M[1]);
	theta = atan(M[2]/norm);
	
	if (norm != 0){
	  invnorm = 1/norm;
	  t  = theta;
	  rho = fisheye_model.invpol[0];
	  t_i = 1;

	  for (k = 1; k < fisheye_model.length_invpol; k++){
	    t_i *= t;
	    rho += t_i*fisheye_model.invpol[k];
	  }
	  
	  x = M[0]*invnorm*rho;
	  y = M[1]*invnorm*rho;
	
	  m[0] = x*fisheye_model.c + y*fisheye_model.d + fisheye_model.xc;
	  m[1] = x*fisheye_model.e + y   + fisheye_model.yc;
	}else{
	  m[0] = fisheye_model.xc;
	  m[1] = fisheye_model.yc;
	}
	
	*( mapx->data.fl + i*mapx->cols+j ) = (float) m[1];
	*( mapy->data.fl + i*mapx->cols+j ) = (float) m[0];
      }
  }
  
  double estimateHeight(double d){
    return -0.0036*d*d + 2.9470*d + 34.6687;
  }
  
  double pixel2meters(double p){
    return 0.0097*p - 0.0179;
  }
  
  bool insideEllipse(cv::RotatedRect e, cv::Point2f p){
    double rot = std::atan2(p.y - e.center.y, p.x - e.center.x);
    
    cv::Point2f ic_ellipse((p.x - e.center.x)*cos(rot) - (p.y - e.center.y)*sin(rot), 
			       (p.x - e.center.x)*sin(rot) + (p.y - e.center.y)*cos(rot));
    
    return (ic_ellipse.x/e.size.width)*(ic_ellipse.x/e.size.width) + (ic_ellipse.y/e.size.height)*(ic_ellipse.y/e.size.height) <= 1;
  }
  
public:
  PersonDetector():it(nh){
    cv::namedWindow("undistorted image", cv::WINDOW_NORMAL);
//     cv::namedWindow("MOG2", cv::WINDOW_NORMAL);
    
    fst_im = true;
    changed_sf = false;
    
    std::string stream, calib_file, data, borders;
    
    ros::NodeHandle pnh("~");
    pnh.getParam("image", stream);
    pnh.getParam("calib_file", calib_file);
    pnh.getParam("data_file", data);
    pnh.getParam("borders_file", borders);
    
    //subscribe video stream
    image_sub = it.subscribe(stream, 1, &PersonDetector::imageCB, this, image_transport::TransportHints("compressed"));
    
    f = boost::bind(&PersonDetector::callbackDR, this, _1, _2);
    server.setCallback(f);
    
    //load calib
    cv::FileStorage fileS(calib_file.c_str(), cv::FileStorage::READ);
    fileS["ss"] >> fisheye_model.pol;
    fileS["invpol"] >> fisheye_model.invpol;
    fileS["center_row"] >> fisheye_model.xc;
    fileS["center_column"] >> fisheye_model.yc;
    fileS["c"] >> fisheye_model.c;
    fileS["d"] >> fisheye_model.d;
    fileS["e"] >> fisheye_model.e;
    fileS["height"] >> fisheye_model.height;
    fileS["width"] >> fisheye_model.width;
    fisheye_model.length_pol = fisheye_model.pol.size();
    fisheye_model.length_invpol = fisheye_model.invpol.size();
    
    //compute map for distorsion removal
    create_undistort_map();
    
    //create Background Subtractor objects
    pMOG2 = new cv::BackgroundSubtractorMOG2(); //MOG2 approach

    data_file = cv::FileStorage(data, cv::FileStorage::WRITE);
    
    borders_file = cv::FileStorage(borders, cv::FileStorage::READ);
    borders_file["surfaces"] >> surf;
    borders_file["tv"] >> tv;
    
    im_center.x = fisheye_model.width/2;
    im_center.y = fisheye_model.height/2;

  }
  
  ~PersonDetector(){
    data_file << "data" << training << "labels" << labels;
    
    cv::destroyAllWindows();

    data_file.release();
    borders_file.release();
  }
  
  void create_undistort_map(){
    CvMat* mapx_persp = cvCreateMat(fisheye_model.height, fisheye_model.width, CV_32FC1);
    CvMat* mapy_persp = cvCreateMat(fisheye_model.height, fisheye_model.width, CV_32FC1);
    create_perspecive_undistortion_LUT( mapx_persp, mapy_persp);
    mapx = cv::Mat(mapx_persp);
    mapy = cv::Mat(mapy_persp);
  }
  
  void callbackDR(hannrs_vision::UndistortConfig &config, uint32_t level){
    sf = config.sf;
    changed_sf = true;
  }
  
  void showImage(){
    if(!fst_im){
      cv::imshow("undistorted image", undistorted_im);
//       cv::imshow("MOG2", fgMaskMOG2);
      cv::waitKey(3);
    }
  }
  
  void find_contours(){
    if(!fst_im){
      std::vector<std::vector<cv::Point> > contoursMOG2;
      std::vector<cv::Vec4i> hierarchyMOG2;
      std::vector<std::vector<cv::Point> > contours_polyMOG2;
      
      cv::Mat thresholdMOG2;

      cv::threshold(fgMaskMOG2, fgMaskMOG2, 254, 255, cv::THRESH_BINARY);
      
      //filter foreground masks    
      cv::morphologyEx(fgMaskMOG2, fgMaskMOG2, cv::MORPH_OPEN, cv::Mat() , 
		       cv::Point(-1,-1), 2, cv::BORDER_CONSTANT, cv::morphologyDefaultBorderValue());
      cv::morphologyEx(fgMaskMOG2, fgMaskMOG2, cv::MORPH_CLOSE, cv::Mat() , 
		       cv::Point(-1,-1), 4, cv::BORDER_CONSTANT, cv::morphologyDefaultBorderValue());
      
      // Find contours
      thresholdMOG2 = fgMaskMOG2.clone();
      cv::findContours(thresholdMOG2, contoursMOG2, hierarchyMOG2, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0) );

      contours_polyMOG2 = std::vector<std::vector<cv::Point> >(contoursMOG2.size());
      ellipseMOG2 = std::vector<cv::RotatedRect>(contoursMOG2.size());
      
      for( int i = 0; i < contoursMOG2.size(); i++ ){ 
	cv::approxPolyDP( cv::Mat(contoursMOG2[i]), contours_polyMOG2[i], 3, true );
	if(contours_polyMOG2[i].size() > 5 && cv::contourArea(contours_polyMOG2[i]) > 3000){
	  ellipseMOG2[i] = cv::fitEllipse(cv::Mat(contours_polyMOG2[i]));
	}
      }
      
    }
  }
  
  void check_person(){
    if(!fst_im){
      cv::circle(undistorted_im, im_center, 10, cv::Scalar(0,255,0), 2, 8);
//       for(unsigned int j = 0; j < surf.size(); j++){
// 	cv::rectangle(undistorted_im, surf[j], cv::Scalar(0,255,0), 2, 8);
//       }
      
      ellipse_filtetred.clear();

      for(unsigned int i = 0; i < ellipseMOG2.size(); i++){
	if(ellipseMOG2[i].size.height > ellipseMOG2[i].size.width){
	  cv::Point2f p = ellipseMOG2[i].center;
	  cv::Size2f s = ellipseMOG2[i].size;

// 	  double dist_to_center = abs(sqrt((p.x-im_center.x)*(p.x-im_center.x) + (p.y-im_center.y)*(p.y-im_center.y)) - s.height/2);
	  if(p.y + s.height/2 - fisheye_model.height <= 0 && p.y + s.width/2 - fisheye_model.height <= 0 &&
	    p.x + s.height/2 - fisheye_model.height <= 0 && p.x + s.width/2 - fisheye_model.height <= 0){
	    if(p.y + s.height/2 - fisheye_model.width <= 0 && p.y + s.width/2 - fisheye_model.width <= 0 &&
	      p.x + s.height/2 - fisheye_model.width <= 0 && p.x + s.width/2 - fisheye_model.width <= 0){
	      if(p.y - s.height/2 > 0 && p.y - s.width/2 > 0){
		if(p.x - s.height/2 > 0 && p.x - s.width/2 > 0){
		  cv::Point2f rect_points[4]; 
		  ellipseMOG2[i].points( rect_points );
		  std::vector<bool> b(4, false);
		  for(unsigned int j = 0; j < surf.size(); j++){
		    if(surf[j].contains((rect_points[0] + rect_points[1])*0.5)){
		      b[0] = b[0] + true;
		    }
		    if(surf[j].contains((rect_points[1] + rect_points[2])*0.5)){
		      b[1] = b[1] + true;
		    }
		    if(surf[j].contains((rect_points[2] + rect_points[3])*0.5)){
		      b[2] = b[2] + true;
		    }
		    if(surf[j].contains((rect_points[3] + rect_points[0])*0.5)){
		      b[3] = b[3] + true;
		    }
		  }
		  bool check = true;
		  for(unsigned int j = 0; j < b.size(); j++){
		    check *= b[j];
		  }
		  if(!check)
		    ellipse_filtetred.push_back(ellipseMOG2[i]);
		}
	      }
	    }
	  }
	}
      }
      
      
      cv::line(undistorted_im, cv::Point(960,0), cv::Point(960,1920), cv::Scalar(0,0,255), 2, 8, 0);
//       for(unsigned int i = 0; i < ellipse_filtetred.size(); i++){
// 	cv::ellipse(undistorted_im, ellipse_filtetred[i], cv::Scalar(255,0,0), 5, 8 );
//       }
      
    }
  }
  
  void spinOnce(){
     ros::spinOnce();
  }
  
  void CallBackFunc(int event, int x, int y, int flags){
    if  (event == cv::EVENT_LBUTTONDOWN){
      double dist_to_center = sqrt((x-im_center.x)*(x-im_center.x) + (y-im_center.y)*(y-im_center.y));
      std::cout << x << " " << y << " " << dist_to_center << std::endl;
      
//       for(unsigned int i = 0; i < ellipse_filtetred.size(); i++){
// 	
// 	if(insideEllipse(ellipse_filtetred[i], cv::Point2f((double)x, (double)y))){
// 	  cv::Point2f p = ellipse_filtetred[i].center;
// 	  cv::Size2f s = ellipse_filtetred[i].size;
// 	  
// 	  double d[4] = {p.x/fisheye_model.width, p.y/fisheye_model.height, s.height/fisheye_model.height, s.width/fisheye_model.width};
// 	  cv::Mat t_row(1, 4, CV_64F, d);
// 	  training.push_back(t_row);
// 	  
// 	  double l = 1.0;
// 	  cv::Mat l_row(1, 1, CV_64F, l);
// 	  labels.push_back(l_row);
// 	}
//       }
    }
    else if( event == cv::EVENT_RBUTTONDOWN ){
      
      for(unsigned int i = 0; i < ellipse_filtetred.size(); i++){
	
	if(insideEllipse(ellipse_filtetred[i], cv::Point2f((double)x, (double)y))){
	  cv::Point2f p = ellipse_filtetred[i].center;
	  cv::Size2f s = ellipse_filtetred[i].size;
	  
	  double d[4] = {p.x/fisheye_model.width, p.y/fisheye_model.height, s.height/fisheye_model.height, s.width/fisheye_model.width};
	  cv::Mat t_row(1, 4, CV_64F, d);
	  training.push_back(t_row);
	  
	  double l = 3.0;
	  cv::Mat l_row(1, 1, CV_64F, l);
	  labels.push_back(l_row);
	}
      }

    }
    else if  ( event == cv::EVENT_MBUTTONDOWN ){
      for(unsigned int i = 0; i < ellipse_filtetred.size(); i++){
	
	if(insideEllipse(ellipse_filtetred[i], cv::Point2f((double)x, (double)y))){
	  cv::Point2f p = ellipse_filtetred[i].center;
	  cv::Size2f s = ellipse_filtetred[i].size;
	  
	  double d[4] = {p.x/fisheye_model.width, p.y/fisheye_model.height, s.height/fisheye_model.height, s.width/fisheye_model.width};
	  cv::Mat t_row(1, 4, CV_64F, d);
	  training.push_back(t_row);
	  
	  double l = 2.0;
	  cv::Mat l_row(1, 1, CV_64F, l);
	  labels.push_back(l_row);
	}
      }
    }
    else if ( event == cv::EVENT_MOUSEMOVE ){
    }
  }
  
};

// This is a function, not a class method
void wrappedCallBackFunc(int event, int x, int y, int flags, void* ptr){
    PersonDetector* mcPtr = (PersonDetector*)ptr;
    if(mcPtr != NULL)
        mcPtr->CallBackFunc(event, x, y, flags);
}

int main(int argc, char* argv[]){
  ros::init(argc, argv, "person_detector");
  
  PersonDetector pd;
  
  //set the callback function for any mouse event
  cv::setMouseCallback("undistorted image", wrappedCallBackFunc, (void*)&pd);
  
  ros::Rate loop_rate(10);
  
  while(ros::ok()){
    pd.find_contours();
    pd.check_person();
    pd.showImage();
    pd.spinOnce();
    
    loop_rate.sleep();
  }
  
  return 0;
}
